import { NextRequest } from 'next/server';
import { auth } from '@/lib/auth';
import { generateObject } from 'ai';
import { z } from 'zod';
import { myProvider } from '@/lib/ai/providers';

export async function POST(request: NextRequest) {
  const session = await auth.api.getSession({
    headers: request.headers
  });
  if (!session?.user?.id) {
    return new Response('Unauthorized', { status: 401 });
  }

  try {
    const { prompt, stepType, targetModel, existingModels } = await request.json();

    if (!prompt) {
      return new Response('Prompt is required', { status: 400 });
    }

    // Define the schema for the AI response
    const suggestionSchema = z.object({
      enhancedPrompt: z.string().describe('An improved version of the original prompt with better clarity and field references'),
      inputFields: z.array(z.object({
        name: z.string().describe('Field name in camelCase'),
        type: z.enum(['text', 'number', 'boolean', 'date', 'json', 'reference', 'enum']).describe('Field type'),
        description: z.string().describe('Brief description of what this field contains'),
        isCustom: z.boolean().describe('True if this field doesn\'t exist in the target model'),
        required: z.boolean().describe('Whether this field is essential for the step'),
        customFieldType: z.enum(['scalar', 'existing_model', 'new_model']).optional().describe('For custom fields, whether it\'s a scalar value, existing model reference, or new model reference'),
        referencesModel: z.string().optional().describe('If type is reference, which model it references'),
        enumValues: z.array(z.string()).optional().describe('For enum fields, the list of possible values')
      })).describe('Input fields needed for this step'),
      outputFields: z.array(z.object({
        name: z.string().describe('Field name in camelCase'),
        type: z.enum(['text', 'number', 'boolean', 'date', 'json', 'reference', 'enum']).describe('Field type'),
        description: z.string().describe('Brief description of what this field will contain'),
        isCustom: z.boolean().describe('True if this field doesn\'t exist in the target model'),
        customFieldType: z.enum(['scalar', 'existing_model', 'new_model']).optional().describe('For custom fields, whether it\'s a scalar value, existing model reference, or new model reference'),
        referencesModel: z.string().optional().describe('If type is reference, which model it references'),
        enumValues: z.array(z.string()).optional().describe('For enum fields, the list of possible values')
      })).describe('Output fields that will be generated by this step'),
      suggestedModels: z.array(z.object({
        name: z.string().describe('Model name in PascalCase'),
        description: z.string().describe('Brief description of what this model represents'),
        fields: z.array(z.object({
          name: z.string().describe('Field name in camelCase'),
          type: z.enum(['text', 'number', 'boolean', 'date', 'json', 'reference', 'enum']).describe('Field type'),
          description: z.string().describe('Brief description of the field'),
          required: z.boolean().describe('Whether this field is required'),
          enumValues: z.array(z.string()).optional().describe('For enum fields, the list of possible values')
        })).describe('Fields for the new model')
      })).describe('New models that might be needed based on the prompt')
    });

    const systemPrompt = `You are an AI assistant that analyzes user prompts for data processing steps and suggests appropriate input/output fields.

IMPORTANT CONTEXT: This step will process ONE RECORD at a time from the ${targetModel || 'target'} model. The step reads data from a single record, processes it, and updates/generates new fields for that same record.

Given a user's prompt for a ${stepType} step that processes individual ${targetModel || 'target'} records, analyze what data inputs are needed and what outputs should be generated.

Context:
- Step Type: ${stepType}
- Target Model: ${targetModel || 'Not specified'}
- Existing Models: ${JSON.stringify(existingModels || [], null, 2)}

CRITICAL: The target model "${targetModel}" already has these fields - DO NOT suggest them as custom fields:
${targetModel ?
        (existingModels?.find((m: any) => m.name === targetModel)?.fields || [])
          .map((f: any) => `- ${f.name} (${f.type}${f.enumValues ? ` - values: ${f.enumValues.join(', ')}` : ''})`)
          .join('\n') : 'No existing fields'}

MANDATORY FIELD VALIDATION RULES:
1. BEFORE suggesting ANY field, check if it exists in the target model field list above
2. If a field name matches ANY existing field name, DO NOT suggest it as custom (isCustom: true)
3. Instead, suggest it with isCustom: false to use the existing field
4. FORBIDDEN PATTERNS:
   - If "name" exists, DO NOT suggest "customerName", "petName", "userName", etc.
   - If "healthStatus" exists, DO NOT suggest "petHealthStatus", "animalHealthStatus", etc.
   - If "email" exists, DO NOT suggest "customerEmail", "userEmail", etc.
5. ONLY suggest custom fields (isCustom: true) for completely new concepts not covered by existing fields

EXISTING FIELD USAGE:
- To reference existing "name" field: { name: "name", isCustom: false }
- To reference existing "healthStatus": { name: "healthStatus", isCustom: false }
- To reference existing "email": { name: "email", isCustom: false }
- Custom fields should be for NEW concepts only: { name: "aiAnalysis", isCustom: true }

 Guidelines:
 1. For INPUT FIELDS: 
    - FIRST check if needed fields already exist in the target model
    - Use existing fields whenever possible (mark isCustom: false)
    - Only suggest custom fields (isCustom: true) for truly new data
    - Think: "What data from THIS SINGLE ${targetModel || 'record'} does the step need to read?"
 2. For OUTPUT FIELDS: 
    - Identify what new data the step will generate or modify FOR THIS SINGLE RECORD
    - Think: "What new fields will be added/updated on THIS SINGLE ${targetModel || 'record'}?"
    - IMPORTANT: If you suggest a new model, create ONE output field that references that model
    - DO NOT break down new models into individual fields - suggest the model reference instead
    - Example: If suggesting HealthCampaign model, output field should be "healthCampaigns" (reference to HealthCampaign)
    - NOT: campaignName, campaignDescription, campaignStartDate (individual fields)
 3. For ENHANCED PROMPT: 
    - Improve the original prompt with better clarity and proper field references using {fieldName} syntax
    - Make it clear the prompt is for processing ONE ${targetModel || 'record'} at a time
    - Use singular language: "Analyze this pet's health" not "Analyze pets' health"
 4. For SUGGESTED MODELS: If the step involves creating complex structured data, suggest new models
 5. Use camelCase for field names (e.g., firstName, totalAmount, createdAt)
 6. Mark fields as custom if they don't exist in the current target model
 7. For custom fields, determine the appropriate customFieldType:
    - 'scalar': Simple values like text, numbers, booleans (e.g., calculatedScore, isProcessed)
    - 'existing_model': References to models that already exist in the system
    - 'new_model': References to complex objects that would need new models (e.g., analysisReport, healthMetrics)
 8. CRITICAL MODEL REFERENCE RULE:
    - When suggesting a new model (e.g., HealthCampaign), create a reference field to that model
    - Output field name should be plural of model name (e.g., "healthCampaigns" for HealthCampaign model)
    - Set type: "reference", customFieldType: "new_model", referencesModel: "HealthCampaign"
         - The model's individual fields go in suggestedModels, NOT in outputFields
 9. For reference fields, specify which model they reference
 10. For enum fields, provide specific possible values (e.g., ["healthy", "needs_review", "sick"] for healthStatus)
 11. Use enum type for status fields, categories, and other constrained values
 12. Be practical - don't over-engineer, suggest only what's truly needed

 Examples of good field suggestions for single record processing:
 - Input: {customerEmail}, {orderAmount}, {productId}, {healthStatus} (read from THIS record)
 - Output: processedStatus (enum: ["processed", "pending", "failed"]), calculatedTax, healthCampaigns (reference to HealthCampaign model)
 - WRONG: campaignName, campaignDescription, campaignStartDate (individual model fields)
 - RIGHT: healthCampaigns (single reference field to HealthCampaign model)
 - Enhanced prompts: "Analyze this pet's {healthStatus} and {lastCheckup} to determine care needs" (singular, record-specific)
 - Enum examples: healthStatus: ["healthy", "needs_review", "sick"], orderStatus: ["pending", "shipped", "delivered"]
 - New models: HealthCampaign (with fields: name, description, startDate, endDate), OrderSummary, CustomerProfile`;

    const result = await generateObject({
      model: myProvider.languageModel('chat-model'),
      schema: suggestionSchema,
      prompt: `${systemPrompt}

User's prompt: "${prompt}"

Please analyze this prompt and suggest appropriate input fields, output fields, an enhanced prompt, and any new models that might be needed.

FINAL VALIDATION: Before responding, double-check that you have NOT suggested any custom fields (isCustom: true) that match existing field names. If you need an existing field, use isCustom: false instead.`,
    });

    return Response.json(result.object);

  } catch (error) {
    console.error('Error suggesting fields:', error);
    return new Response('Internal Server Error', { status: 500 });
  }
} 